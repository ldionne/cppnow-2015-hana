<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>C++ metaprogramming: a paradigm shift</title>

        <meta name="author" content="Louis Dionne">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">
        <link rel="stylesheet" href="css/custom.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown=""
                         data-separator="^====+$"
                         data-separator-vertical="^----+$"
                         data-notes="^Note:">
                <script type="text/template">

## C++ metaprogramming
<h3 style="opacity: 0.8">a paradigm shift</h3>
<br>
Louis Dionne, C++Now 2015

====================

### Such a cocky title

====================

## Outline
- What?
- Why?
- How?

<!-- Define new MathJax commands here to avoid seeing them load on the first slide. -->
$\newcommand{\cc}[1]{{\tt #1}}$

==============================================================================

### What are the types of sequences in C++?

====================

### Homogeneous dynamic sequences (classic)

#### Extensible

```c++
std::vector<int> seq;
int i = 0;
while (dynamic_condition())
  seq.push_back(i++);
```

#### Fixed-size

```c++
std::array<std::string, 10> seq;
for (std::string& s: seq)
  s = user_input();
```

----

### Homogeneous `constexpr` sequences

#### Extensible

```c++
TODO: tricky constexpr linked list
```

#### Fixed-size

```c++
constexpr std::array<int, 10> seq = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
constexpr int i = seq[3];
```

====================

### Heterogeneous dynamic sequences

#### Extensible

impossible

#### Fixed-size

```c++
std::tuple<std::string, std::vector<int>> seq{user_input(), stuff()};
std::string& s = std::get<0>(seq);
```

----

### Heterogeneous `constexpr` sequences

#### Extensible

impossible

#### Fixed-size

```c++
constexpr std::tuple<int, char, float> seq = {1, 'c', 3.4f};
constexpr char c = std::get<1>(seq);
```

====================

### Type-level sequences

```c++
using seq = vector<int, char, float, int_<3>>;
using c = at_c<seq, 1>::type;
```

====================

### `constexpr` and heterogeneity are orthogonal

<!-- TODO: Harmonize above this with below this -->

====================

## What are type-level computations?

----

### Metafunctions

```cpp
template <typename T>
struct add_pointer {
    using type = T*;
};

using result = add_pointer<int>::type;
```

----

### Sequences (of types)

```cpp
template <typename ...T>
struct vector;

using types = vector<int, char, float, void>;
```

----

### Algorithms (on sequences of types)

```cpp
template <typename Vector>
struct front;

template <typename T, typename ...Ts>
struct front<vector<T, Ts...>> {
    using type = T;
};

using types = vector<int, char, float, void>;
using first = front<types>::type; // int
```

----

### More algorithms

```cpp
template <typename Vector, template <typename ...> class Metafunction>
struct transform;

template <typename ...T, template <typename ...> class Metafunction>
struct transform<vector<T...>, Metafunction> {
    using type = vector<typename Metafunction<T>::type...>;
};

using types = vector<int, char, float, void>;
using pointers = transform<types, add_pointer>::type;
// vector<int*, char*, float*, void*>
```

====================

### What is it useful for?

<!-- TODO: Find a simple but useful use case -->

====================

## What are heterogeneous computations?

----

### Heterogeneous functions

```cpp
struct widen {
    long double operator()(long double x) const { return x; }
    long double operator()(double x) const { return x; }
    long double operator()(float x) const { return x; }

    long long operator()(int x) const { return x; }
    long long operator()(long x) const { return x; }
    long long operator()(long long x) const { return x; }

    // etc...
};

long double x = widen{}(3.4);
long long y = widen{}(23);
```

----

### Heterogeneous sequences

```cpp
template <typename ...T>
struct vector {
    // essentially a std::tuple
};

vector<int, long, float> values = {1, 2l, 3.4f};
```

----

### Algorithms (on heterogeneous sequences)

```cpp
template <typename T, typename ...Ts>
T front(vector<T, Ts...> v) {
    // ...
}

vector<int, long, float> values = {1, 2l, 3.4f};
int one = front(values);
```

----

### More algorithms

```cpp
template <typename ...T, typename F>
auto // <-- depends on the return type of f on each element
transform(vector<T...> v, F f) {
    // ...
}

vector<int, long, float> values = {1, 2l, 3.4f};
vector<long long, long long, long double> wide_values =
                            transform(values, widen{});
```

====================

### What is it useful for?

<!-- TODO: Find a simple but useful use case -->

====================

## What do I propose?
### Merge both <!-- .element class="fragment" -->

==============================================================================

## Why?

====================

### C++14 is a serious game changer

----

### Automatically deduced return type

----

### Generalized constexpr

----

### Generic lambdas

----

### Variable templates

====================

### See for yourself

====================

### Loop unrolling: then

```cpp
__attribute__((noinline)) void f() { }

int main() {
    #pragma PLZ UNROLL
    for (int i = 0; i != 10; ++i)
        f();
}
```

----

### Loop unrolling: now

```cpp
__attribute__((noinline)) void f() { }

int main() {
    int_<10>.times(f);
}
```

----

### Skeptical?

```
_main:
    ; snip
    push    rbp
    mov rbp, rsp
    call __Z1fv
    call __Z1fv
    call __Z1fv
    call __Z1fv
    call __Z1fv
    call __Z1fv
    call __Z1fv
    call __Z1fv
    call __Z1fv
    call __Z1fv
    xor eax, eax
    pop rbp
    ret
```

====================

### Checking for a member: then

```cpp
template <typename T, typename = decltype(&T::xxx)>
static std::true_type has_xxx_impl(int);

template <typename T>
static std::false_type has_xxx_impl(...);

template <typename T>
struct has_xxx
    : decltype(has_xxx_impl<T>(int{}))
{ };

struct Foo { int xxx; };
static_assert(has_xxx<Foo>::value, "");
```

----

### Checking for a member: soon

```cpp
template <typename T, typename = void>
struct has_xxx
    : std::false_type
{ };

template <typename T>
struct has_xxx<T, std::void_t<decltype(&T::xxx)>>
    : std::true_type
{ };

struct Foo { int xxx; };
static_assert(has_xxx<Foo>::value, "");
```

----

### Checking for a member: what it should be

```cpp
auto has_xxx = is_valid([](auto t) -> decltype(t.xxx) {});

struct Foo { int xxx; };
static_assert(has_xxx(type<Foo>), "");
```

====================

### Sorting at compile-time: then

```cpp
template <typename Sequence, typename Pred>
struct sort;

template <typename Pred, typename Pivot>
struct sort_pred {
  template <typename T>
  using apply = apply2<Pred, T, Pivot>;
};

template <typename Sequence, typename Pred>
struct sort_impl {
  using pivot = typename begin<Sequence>::type;
  using parts = typename partition<
    iterator_range<typename next<pivot>::type,
                   typename end<Sequence>::type>
    , protect<sort_pred<Pred, typename deref<pivot>::type>>
    , back_inserter<vector<>>
    , back_inserter<vector<>>
  >::type;

  using part1 = typename push_back<
    typename sort<typename parts::first, Pred>::type,
    typename deref<pivot>::type
  >::type;

  using part2 = typename sort<typename parts::second, Pred>::type;

  using type = typename insert_range<
    part1, typename end<part1>::type, part2
  >::type;
};

template <typename Sequence, typename Pred>
struct sort
  : eval_if<empty<Sequence>,
      identity<Sequence>,
      sort_impl<Sequence, Pred>
  >
{ };
```

<!-- TODO: The code does not fit in one slide -->

----

### Sorting at compile-time: now

```cpp
auto sort = fix([](auto sort, auto xs, auto pred) {
  return eval_if(length(xs) < size_t<2>,
    lazy(xs),
    lazy([=](auto xs) {
      auto pivot = head(xs);
      auto rest = tail(xs);
      auto parts = partition(rest, partial(pred, pivot));
      return concat(
        sort(second(parts), pred),
        prepend(pivot, sort(first(parts), pivot))
      );
    })(xs)
  );
});
```

====================

### Introspection: then

```cpp
namespace keys {
    struct name;
    struct age;
}

namespace demo { }
BOOST_FUSION_DEFINE_ASSOC_STRUCT( // must appear at global scope
    (demo), Person,
    (std::string, name, keys::name)
    (int, age, keys::age)
)

int main() {
    demo::Person john{"John", 30};
    std::string name = at_key<keys::name>(john);
    int age = at_key<keys::age>(john);
}
```

----

### Introspection: now

```cpp
namespace demo {
    struct Person {
        BOOST_HANA_DEFINE_STRUCT(Person,
            (std::string, name),
            (int, age)
        );
    };
}

int main() {
    demo::Person john{"John", 30};
    std::string name = at_key(john, BOOST_HANA_STRING("name"));
    int age = at_key(john, BOOST_HANA_STRING("age"));
}
```

====================

### Compile-times: then and now

<!-- .slide: data-state="haschart" -->
<div class="benchmark-chart" data-dataset="benchmark.including.compile.json"></div>

----

<!-- .slide: data-state="haschart" -->
<div class="benchmark-chart" data-dataset="benchmark.fold_left.compile.json"></div>

----

<!-- .slide: data-state="haschart" -->
<div class="benchmark-chart" data-dataset="benchmark.transform.compile.json"></div>

====================

<!--
TODO: The example is bad; basically it only shows that `unpack` is
implemented in Hana.
-->

### Calling a function with a `tuple`: then

```cpp
template <typename Tuple, typename F, std::size_t ...i>
constexpr decltype(auto)
unpack_impl(Tuple&& tuple, F&& f, std::index_sequence<i...>) {
  return std::forward<F>(f)(std::get<i>(std::forward<Tuple>(tuple))...);
}

template <typename Tuple, typename F>
constexpr decltype(auto) unpack(Tuple&& tuple, F&& f) {
    constexpr std::size_t n = std::tuple_size<
        std::remove_reference_t<Tuple>
    >::value;
    return unpack_impl(std::forward<Tuple>(tuple), std::forward<F>(f),
                       std::make_index_sequence<n>{});
}

void f(int a, double b, std::string c) {
  std::cout << a << ":" << b << ":" << c << std::endl;
}

int main() {
  unpack(std::make_tuple(1, 3.4, "abcdef"), f);
}
```

----

### Calling a function with a `tuple`: now

```cpp
void f(int a, double b, std::string c) {
  std::cout << a << ":" << b << ":" << c << std::endl;
}

int main() {
  unpack(make_tuple(1, 3.4, "abcdef"), f);
}
```

====================

## Still not convinced?
### Here's more

====================

### Accessing an element of a tuple: then

```cpp
std::tuple<int, char, float> values = {1, 'x', 3.4f};
char x = std::get<1>(values);
```

----

### Accessing an element of a tuple: now

```cpp
hana::_tuple<int, char, float> values = {1, 'x', 3.4f};
char x = values[1_c];
```

<!-- TODO: more convincing examples -->

====================

## We must rethink metaprogramming

==============================================================================

## But how?

Note:
Hopefully you are now convinced that there's a better way to write metaprograms.
Let me try to convince you I found it.

====================

### What are types?

----

### Aren't they values after all?

```cpp
using result = add_pointer<int>::type;
```

----

### Let's treat them as such!

```cpp
class Type {
    // ...
};

Type t{...};
```

====================

### What are metafunctions?

----

### Aren't they functions after all?

```c++
template <typename T>
struct add_pointer {
    using type = T*;
};
```

----

### Let's treat them as such!

```c++
Type add_pointer(Type);
bool is_pointer(Type);
bool operator==(Type t, Type u);
// ...

Type t{...};
Type t_ptr = add_pointer(t);
assert(is_pointer(t));
```

====================

### It turns out...
#### The interface is precisely `<type_traits>`

```c++
add_pointer  -> std::add_pointer
add_const    -> std::add_const
add_volatile -> std::add_volatile
// ...

is_pointer   -> std::is_pointer
is_const     -> std::is_const
is_volatile  -> std::is_volatile
// ...

operator==  -> std::is_same
// ...
```

----

### Cool idea, but useless for metaprogramming

====================

### Easy fix: use templates

```cpp
template <typename T>
class Type { /* nothing */ };
```

----

### Easy fix: use templates

```cpp
template <typename T>
Type<T*> add_pointer(Type<T>) { return {}; }

template <typename T>
constexpr bool is_pointer(Type<T>) { return false; }

template <typename T>
constexpr bool is_pointer(Type<T*>) { return true; }
```

----

### Tadam!

```cpp
Type<int> i{};
auto i_ptr = add_pointer(i);
static_assert(is_pointer(i_ptr), "");
```

----

### Pass me the sugar, please

```cpp
template <typename T>
constexpr Type<T> type{};

auto i = type<int>;
auto i_ptr = add_pointer(i);
static_assert(is_pointer(i_ptr), "");
```

====================

### A generic lifting process

#### Let's reconsider:

```c++
template <typename T>
Type<T*> add_pointer(Type<T>) { return {}; }
```

----

#### Could also be written as:

```c++
template <typename T>
auto add_pointer(Type<T>) {
    return type<typename std::add_pointer<T>::type>;
}
```

----

### There's a pattern!

```cpp
template <template <typename ...> class F>
struct Metafunction {
    template <typename ...T>
    auto operator()(Type<T> ...) const {
        return type<
            typename F<T...>::type
        >;
    }
};

Metafunction<std::add_pointer> add_pointer{};

auto i = type<int>;
auto i_ptr = add_pointer(i);
static_assert(is_pointer(i_ptr), "");
```

----

### Sugar, again

```cpp
template <template <typename ...> class F>
constexpr Metafunction<F> metafunction{};

auto add_pointer = metafunction<std::add_pointer>;
auto remove_reference = metafunction<std::remove_reference>;
auto add_const = metafunction<std::add_const>;
// ...
```

====================

### So we can represent types as values

----

### But how can we get back the types?

```c++
auto t = add_pointer(type<int>); // could be a complex type computation
using T = the-type-represented-by-t;
// do something useful with T here...
```

----

### `decltype` baby!

```c++
template <typename T>
struct Type {
    using type = T;
};

auto t = add_pointer(type<int>);
using T = decltype(t)::type;
static_assert(std::is_same<T, int*>{}, "");
// do something useful with T here...
```

====================

### 3 step process

1. Wrap types into `type<...>`
2. Perform computations
3. Unwrap with `decltype(...)::type`

----

## Isn't that cumbersome?
### Not really <!-- .element class="fragment" -->

----

### Only done at some thin boundaries

```c++
auto t = type<T>;
auto result = huge_type_computation(t);
using Result = decltype(result)::type;
```

<!-- TODO: Better example -->

----

### Not always required

```c++
auto t = type<T>;
auto result = f(t);
static_assert(result == type<Something>, "");
```

<!-- TODO: Better example -->

Note:
We did not have to do the third step because we did not need the type itself.

----

### Converting between MPL and Fusion is _way_ more painful

```c++
TODO
```

====================

## But what does that buy us?

====================

### Full language can be used

__Before__
```cpp
using ts = vector<int, char&, void*>;
using us = copy_if<ts, or_<std::is_pointer<_1>,
                           std::is_reference<_1>>>::type;
```

----

__After__
```cpp
auto ts = make_tuple(type<int>, type<char&>, type<void*>);
auto us = filter(ts, [](auto t) {
  return or_(is_pointer(t), is_reference(t));
});
```

====================

### Only one library is required

__Before__
```cpp
// types (MPL)
using ts = mpl::vector<int, char&, void*>;
using us = mpl::copy_if<ts, mpl::or_<std::is_pointer<_1>,
                                     std::is_reference<_1>>>::type;

// values (Fusion)
auto vs = fusion::make_vector(1, 'c', nullptr, 3.5);
auto ws = fusion::filter_if<std::is_integral<mpl::_1>>(vs);
```

----

__After__
```cpp
// types
auto ts = make_tuple(type<int>, type<char&>, type<void*>);
auto us = filter(ts, [](auto t) {
  return or_(is_pointer(t), is_reference(t));
});

// values
auto vs = make_tuple(1, 'c', nullptr, 3.5);
auto ws = filter(vs, [](auto t) {
  return is_integral(type<decltype(t)>);
});
```

----

### Sugar

```cpp
// types
auto ts = tuple_t<int, char&, void*>;
auto us = filter(ts, [](auto t) {
  return or_(is_pointer(t), is_reference(t));
});

// values
auto vs = make_tuple(1, 'c', nullptr, 3.5);
auto ws = filter(vs, [](auto t) {
  return is_integral(t);
});
```

====================

### Example: type safe `printf`

```cpp
type_safe_printf(BOOST_HANA_STRING("%i, %f, %s"), 2, 3.4, "abcd");
```

----

### Wrong argument type? No problem

```cpp
type_safe_printf(BOOST_HANA_STRING("%i, %f, %s"), 2, 2, "abcd");
```

```c++
[...]/how-printf.cpp:38:5: error: static_assert failed
  "the type of the argument does not match the format character"
  static_assert(decltype(formats[format_char] == arg_type){},
  ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

----

### Wrong number of arguments? No problem

```cpp
type_safe_printf(BOOST_HANA_STRING("%i, %f, %s"), 2, 3.4);
```

```c++
[...]/how-printf.cpp:33:3: error: static_assert failed
  "number of arguments not matching the number of format characters"
  static_assert(length(format_chars) == sizeof...(args),
  ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

----

### Step 1: Specify format characters

```cpp
auto formats = make_map(
  make_pair(char_<'i'>, type<int>),
  make_pair(char_<'f'>, type<double>),
  make_pair(char_<'s'>, type<char*>)

  // ...
);
```

----

### Step 2: Ensure a compile-time format string

```c++
template <typename Fmt, typename ...Args>
int type_safe_printf(Fmt fmt, Args const& ...args) {
  static_assert(is_a<String>(fmt),
  "the format string must be a compile-time hana::String");

  // ...

  return std::printf(to<char const*>(fmt), args...);
};
```

----

### Step 3: Extract the format characters

```c++
template <typename Fmt, typename ...Args>
int type_safe_printf(Fmt fmt, Args const& ...args) {
  static_assert(is_a<String>(fmt),
  "the format string must be a compile-time hana::String");

  auto format_chars = filter(to<Tuple>(fmt), [](auto c) {
    return c ^in^ formats;
  });

  // ...

  return std::printf(to<char const*>(fmt), args...);
};
```

----

### Step 4: Check the number of arguments

```c++
template <typename Fmt, typename ...Args>
int type_safe_printf(Fmt fmt, Args const& ...args) {
  static_assert(is_a<String>(fmt),
  "the format string must be a compile-time hana::String");

  auto format_chars = filter(to<Tuple>(fmt), [](auto c) {
    return c ^in^ formats;
  });

  static_assert(length(format_chars) == sizeof...(args),
  "number of arguments not matching the number of format characters");

  // ...

  return std::printf(to<char const*>(fmt), args...);
};
```

----

### Step 5: Check the type of each argument

```cpp
template <typename Fmt, typename ...Args>
int type_safe_printf(Fmt fmt, Args const& ...args) {
  static_assert(is_a<String>(fmt),
  "the format string must be a compile-time hana::String");

  auto format_chars = filter(to<Tuple>(fmt), [](auto c) {
    return c ^in^ formats;
  });

  static_assert(length(format_chars) == sizeof...(args),
  "number of arguments not matching the number of format characters");

  auto conversions = zip(tuple_t<std::decay_t<Args>...>, format_chars);
  for_each(conversions, fuse([](auto arg_type, auto format_char) {
    static_assert(decltype(formats[format_char] == arg_type){},
    "the type of the argument does not match the format character");
  }));

  return std::printf(to<char const*>(fmt), args...);
};
```

====================

## My proposal: Hana
### Heterogeneous + type level computations

====================

<!-- TODO: Introduce the features of the library through use cases -->

### Heterogeneous sequences

- `tuple`
- `range`
- `map`
- `set`

----

### Heterogeneous algorithms

- `transform`
- `fold`s
- `filter`
- `reverse`
- much more totaling ~75 algorithms

(Fusion has ~50)

----

### Tools to simplify common patterns

- `sfinae`
- loop unrolling
- TODO

<!-- TODO: find a place to introduce IntegralConstant -->

====================

### Fully functional on C++14 compilers

- Clang >= 3.5
- GCC 5 (almost)

<!-- TODO: correct this if we don't make it with GCC -->

====================

### Available in your next Boost release!
#### (hopefully)

====================

### Formal review: June 10 - June 24

====================

### Save yourself some pain and try it!

==============================================================================

# Thank you

<span class="fragment fade-in">
http://ldionne.com <br>
http://github.com/ldionne
</span>

<!--
TODO:
Potential case studies:
- tuple_cat
- common_type
- Heterogeneous linear algebra
- Boost.Accumulators
-->

                </script>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            Reveal.initialize({
                slideNumber: true,
                history: true,
                transition: 'slide',

                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/math/math.js', async: true }
                ]
            });
        </script>

        <!-- Additional javascript for drawing charts. -->
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
        <script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
        <script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
        <script type="text/javascript" src="js/chart.js"></script>
        <script type="text/javascript" src="https://cdn.rawgit.com/michael/github/fb54ae3856341ef4bd3acf877ccf24836fc079d9/github.js"></script>
        <script type="text/javascript">
          window.onload = function() {
            var github = new Github({});
            var hana = github.getRepo('ldionne', 'hana');
            hana.getRef('heads/datasets', function(err, sha) {
              var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.5.0/";

              $(".benchmark-chart").each(function(index, div) {
                var dataset = div.getAttribute("data-dataset");
                $.getJSON(repo + dataset, function(options) {
                  Hana.initChart($(div), options);
                });
              });
            });
          };
        </script>

        <!--
          Some slides contain charts in them. Sometimes, the charts will not
          be properly centered in the slide. To fix this, slides with the
          `data-state="haschart"` attribute trigger a reflowing of all the
          charts inside their div, which is overkill but fixes the problem.
        -->
        <script type="text/javascript">
          Reveal.addEventListener('haschart', function() {
            Highcharts.charts.forEach(function(chart) {
              chart.reflow();
            });
          }, false);
        </script>

    </body>
</html>

